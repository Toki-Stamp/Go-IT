/**
 * Created by Fomichev Yuri on 07.06.2018
 * Contact me at : toki.stamp@gmail.com
 */

'use strict';

/* http://learn.javascript.ru/task/throttle */

/*
    Напишите функцию throttle(f, ms) – «тормозилку», которая возвращает обёртку,
    передающую вызов f не чаще, чем раз в ms миллисекунд.
    
    У этой функции должно быть важное существенное отличие от debounce:
    если игнорируемый вызов оказался последним, т.е. после него до окончания задержки
    ничего нет – то он выполнится.

    Чтобы лучше понять, откуда взялось это требование, и как throttle должна работать –
    разберём реальное применение, на которое и ориентирована эта задача.

    Например, нужно обрабатывать передвижения мыши.

    В JavaScript это делается функцией, которая будет запускаться при каждом
    микро-передвижении мыши и получать координаты курсора. По мере того,
    как мышь двигается, эта функция может запускаться очень часто, может быть 100 раз
    в секунду (каждые 10 мс).

    Функция обработки передвижения должна обновлять некую информацию на странице.
    При этом обновление – слишком «тяжёлый» процесс, чтобы делать его при каждом
    микро-передвижении. Имеет смысл делать его раз в 100 мс, не чаще.

    Пусть функция, которая осуществляет это обновление по передвижению,
    называется onmousemove.

    Вызов throttle(onmousemove, 100), по сути, предназначен для того, чтобы
    «притормаживать» обработку onmousemove. Технически, он должен возвращать обёртку,
    которая передаёт все вызовы onmousemove, но не чаще чем раз в 100 мс.

    При этом промежуточные движения можно игнорировать, но мышь в конце концов где-то
    остановится. И это последнее, итоговое положение мыши обязательно нужно обработать!

    Визуально это даст следующую картину обработки перемещений мыши:
    Первое обновление произойдёт сразу (это важно, посетитель тут же видит реакцию
    на своё действие).
    Дальше может быть много вызовов (микро-передвижений) с разными координатами,
    но пока не пройдёт 100 мс – ничего не будет.
    По истечении 100 мс – опять обновление, с последними координатами. Промежуточные
    микро-передвижения игнорированы.
    В конце концов мышь где-то остановится, обновление по окончании очередной
    паузы 100 мс сработает с последними координатами.
    Ещё раз заметим – задача из реальной жизни, и в ней принципиально важно,
    что последнее передвижение обрабатывается. Пользователь должен увидеть,
    где остановил мышь.

    Пример использования:
    
    var f = function(a) {
        console.log(a)
    };

    затормозить функцию до одного раза в 1000 мс
    var f1000 = throttle(f, 1000);

    f1000(1); // выведет 1
    f1000(2); // (тормозим, не прошло 1000 мс)
    f1000(3); // (тормозим, не прошло 1000 мс)

    когда пройдёт 1000 мс...
    выведет 3, промежуточное значение 2 игнорируется
*/

function fn(value) {
    console.log(value);
}

function throttle(callback, time) {
    let stop     = false,
        lastCall = {
            context: null,
            args   : null
        };
    
    return function wrapper() {
        if (stop) {
            console.log('ignored', arguments[0]);
            
            lastCall = {
                context: this,
                args   : arguments
            }
        } else {
            callack.apply(this, arguments);
            stop = true;
            
            setTimeout(function () {
                stop = false;
                
                if (lastCall) {
                    lastCall.args[0] = 'throttled ' + lastCall.args[0];
                    wrapper.apply(lastCall.context, lastCall.args);
                    lastCall = null;
                }
            }, time);
        }
    };
}

var f1000 = throttle(fn, 1000);

f1000(1); // выведет 1
f1000(2); // (тормозим, не прошло 1000 мс)
f1000(3); // (тормозим, не прошло 1000 мс)
setTimeout(function () {f1000('4')}, 100);
setTimeout(function () {f1000('5')}, 700);
setTimeout(function () {f1000('6')}, 900);
setTimeout(function () {f1000('7')}, 1100);
setTimeout(function () {f1000('8')}, 1500);
setTimeout(function () {f1000('9')}, 2200);
setTimeout(function () {f1000('10')}, 2300);